#!/usr/bin/env perl

use strict;
use warnings;
use feature 'say';
use File::Basename;
use File::Path qw(remove_tree make_path);
use Getopt::Long;
use POSIX qw(strftime);

Getopt::Long::Configure('bundling');

our $GITREWIND_DIR = "$ENV{HOME}/.gitrewind";

# flags
our $CLEANUP = 0;
our $LIST    = 0;
our $BRANCH  = '';

sub usage {
    die "Usage: gitrew [-lcb] timestamp\n".
        "Flags:\n".
        "  -l, --list     Show snapshots (~/.gitrewind dir by default) end exit\n".
        "  -c, --cleanup  Delete all snapshots (~/.gitrewind dir by default)\n".
        "  -b, --branch   Specify a Git branch (otherwise, the current one is used)\n".
        "Examples:\n".
        "  gitrew 2 weeks ago\n".
        "  gitrew -b master 2 minute ago\n".
        "  gitrew 2026-02-08 15:52\n".
        "Warning: Git's date parser is very strange. 'gibberish' may return\n".
        "         the latest commit. Use proper timestamps e.g. like above\n";
}

sub main {
    if (system("git rev-parse --git-dir >/dev/null 2>&1")) {
        say "Not git repo\n";
        usage();
    }

    my $datetime;

    # ==== find commit the commit closest to the date ====
    $datetime = join(' ', @ARGV);

    unless ($datetime) {
        usage() if !$CLEANUP;
        exit 0;
    }
    
    my $hash;
    if ($BRANCH) {
        $hash = `git log -n1 $BRANCH --before="$datetime" --format="%H" 2>/dev/null`;
    } else {
        # current branch
        $hash = `git log -n1 --first-parent --before="$datetime" --format="%H" 2>/dev/null`;
    }
    chomp $hash;
    
    die "There was only darkness: $datetime\n" if !$hash;

    # ==== preparing the directory for snapshot ====
    my $repo_root = `git rev-parse --show-toplevel`;
    chomp $repo_root;
    my $repo_name = basename($repo_root);

    my $safe_datetime = $datetime;
    $safe_datetime =~ s/ /_/g;
    $safe_datetime =~ s/:/-/g;
    
    my $current_time = strftime("%Y-%m-%d_%H:%M", localtime());
    $current_time =~ s/:/-/g;
    
    make_path($GITREWIND_DIR) unless -d $GITREWIND_DIR;

    my $snapshot_dir = "$GITREWIND_DIR/${repo_name}__${safe_datetime}__${current_time}";
    
    remove_tree($snapshot_dir) or die "Cannot remove: $!\n" if -d $snapshot_dir;
    make_path($snapshot_dir) or die "Cannot create: $!\n";

    # ==== take snapshot ====
    my $output = `git archive $hash | tar -x -C '$snapshot_dir' 2>&1`;

    if ($? != 0) {
        remove_tree($snapshot_dir);
        die "Failed:\n$output\n";
    }

    say $snapshot_dir;
}

GetOptions(
    'cleanup|c'  => \$CLEANUP,
    'list|l'     => \$LIST,
    'branch|b=s' => \$BRANCH,
) or usage();

remove_tree($GITREWIND_DIR) or die "Cannot remove: $!\n" if $CLEANUP && -d $GITREWIND_DIR;

if ($LIST) {
    if (-d $GITREWIND_DIR) {
        my $output = `ls -1 $GITREWIND_DIR 2>/dev/null`;
        if ($output) {
            print $output;
        } else {
            say "No snapshots yet";
        }
    } else {
        say "No snapshots yet";
    }
    exit 0;
}

main();
