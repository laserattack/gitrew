#!/usr/bin/env perl

use strict;
use warnings;
use feature 'say';
use File::Basename;
use File::Path qw(remove_tree make_path);
use Getopt::Long;
use POSIX qw(strftime);

Getopt::Long::Configure('bundling');

our $GITREWIND_DIR = "$ENV{HOME}/.gitrewind";

# flags
our $HELP        = 0;
our $CLEANUP     = 0;
our $INTERACTIVE = 0;
our $LIST        = 0;
our $BRANCH      = '';

sub usage {
    die "Usage: gitrew [-hlcib] timestamp\n".
        "Flags:\n".
        "  -h, --help         Show this help message and exit\n".
        "  -l, --list         Show memories (~/.gitrewind dir by default) end exit\n".
        "  -c, --cleanup      Delete memories (~/.gitrewind dir by default)\n".
        "  -i, --interactive  Interactive mode (u need fzf for use it)\n".
        "  -b, --branch       Specify a Git branch (otherwise, the current one is used)\n".
        "Examples:\n".
        "  gitrew 2 weeks ago\n".
        "  gitrew -b master 2 minute ago\n".
        "  gitrew 2026-02-08 15:52\n".
        "  gitrew -b main -i\n".
        "Warning: Git's date parser is very strange. 'gibberish' may return\n".
        "         the latest commit. Use proper timestamps e.g. like above.\n";
}

sub main {
    if (system("git rev-parse --git-dir >/dev/null 2>&1")) {
        say "Not git repo\n";
        usage();
    }

    my $datetime;

    if ($INTERACTIVE) {
        my $log_cmd = "git log --date='format:%Y-%m-%d %H:%M:%S' --format=\"%ad\"";
        
        if ($BRANCH) {
            $log_cmd .= " $BRANCH";
        } else {
            $log_cmd .= " --first-parent";
        }
        
        my $commits = `$log_cmd`;
        my $choice = `echo "$commits" | fzf`;
        chomp $choice;
        $datetime = $choice if $choice;
    } else {
        $datetime = join(' ', @ARGV);
    }
    
    unless ($datetime) {
        usage() if !$CLEANUP;
        exit 0;
    }
    
    my $hash;
    if ($BRANCH) {
        $hash = `git log -n1 $BRANCH --before="$datetime" --format="%H" 2>/dev/null`;
    } else {
        # current branch
        $hash = `git log -n1 --first-parent --before="$datetime" --format="%H" 2>/dev/null`;
    }
    chomp $hash;
    
    die "There was only darkness: $datetime\n" if !$hash;

    my $repo_root = `git rev-parse --show-toplevel`;
    chomp $repo_root;
    my $repo_name = basename($repo_root);

    my $safe_datetime = $datetime;
    $safe_datetime =~ s/ /_/g;

    my $current_time = strftime("%Y-%m-%d_%H:%M:%S", localtime());
    
    make_path($GITREWIND_DIR) unless -d $GITREWIND_DIR;

    my $snapshot_dir = "$GITREWIND_DIR/${repo_name}__${current_time}__${safe_datetime}";

    remove_tree($snapshot_dir) or die "Cannot remove: $!\n" if -d $snapshot_dir;
    make_path($snapshot_dir) or die "Cannot create: $!\n";

    my $output = `git archive $hash | tar -x -C '$snapshot_dir' 2>&1`;

    if ($? != 0) {
        remove_tree($snapshot_dir);
        die "Failed:\n$output\n";
    }

    say $snapshot_dir;
}

GetOptions(
    'help|h'        => \$HELP,
    'cleanup|c'     => \$CLEANUP,
    'interactive|i' => \$INTERACTIVE,
    'list|l'        => \$LIST,
    'branch|b=s'    => \$BRANCH,
) or usage();

if ($CLEANUP) {
    remove_tree($GITREWIND_DIR) or die "Cannot remove: $!\n" if -d $GITREWIND_DIR;
}

if ($LIST) {
    if (-d $GITREWIND_DIR) {
        my $output = `ls -1 $GITREWIND_DIR 2>/dev/null`;
        if ($output) {
            print $output;
        } else {
            say "No memories yet";
        }
    } else {
        say "No memories yet";
    }
    exit 0;
}

main();
