#!/usr/bin/env perl

use strict;
use warnings;
use feature 'say';
use File::Basename;
use File::Path qw(remove_tree make_path);
use Getopt::Long;
use POSIX qw(strftime);

Getopt::Long::Configure('bundling');

our $GITREWIND_DIR = "$ENV{HOME}/.gitrewind";

# flags
our $CLEANUP = 0;
our $LIST    = 0;
our $BRANCH  = '';

sub check_dependencies {
    system("which git >/dev/null 2>&1") == 0 or die "git not found\n";
    system("which tar >/dev/null 2>&1") == 0 or die "tar not found\n";
}

sub usage {
    die "Usage: gitrew [-lcb] timestamp\n".
        "Flags:\n".
        "  -l, --list     Show all snapshots (~/.gitrewind dir) and exit\n".
        "  -c, --cleanup  Delete all snapshots (~/.gitrewind dir) and exit\n".
        "  -b, --branch   Specify a Git branch (otherwise, the current one is used)\n".
        "Examples:\n".
        "  gitrew 2 weeks ago\n".
        "  gitrew -b master 2 minute ago\n".
        "  gitrew 2026-02-08 15:52\n".
        "Warning: Git's date parser is very strange. 'gibberish' may return\n".
        "         the latest commit. Use proper timestamps e.g. like above\n";
}

sub main {
    my $timestamp;

    # ==== find commit the commit closest to the date ====
    $timestamp = join(' ', @ARGV);

    unless ($timestamp) {
        usage() if !$CLEANUP;
        exit 0;
    }
    
    my $hash;
    $hash = `git log -n1 $BRANCH --before="$timestamp" --format="%H" 2>/dev/null`;
    chomp $hash;
    
    die "There was only darkness: $timestamp\n" if !$hash;

    # ==== preparing the directory for snapshot ====
    my $repo_root = `git rev-parse --show-toplevel`;
    chomp $repo_root;
    my $repo_name = basename($repo_root);
    
    make_path($GITREWIND_DIR) unless -d $GITREWIND_DIR;

    my $t = time();
    my $snapshot_base_dir_name = "${repo_name}_${t}";
    my $snapshot_base_dir = "$GITREWIND_DIR/${snapshot_base_dir_name}";
    my $snapshot_dir = "$snapshot_base_dir/${repo_name}";
    
    remove_tree($snapshot_base_dir) or die "Cannot remove: $!\n" if -d $snapshot_base_dir;
    make_path($snapshot_dir) or die "Cannot create: $!\n";

    # ==== crete metadata file ====
    my $meta_file = "$snapshot_base_dir/metadata";
    open my $fh, '>', $meta_file or die "Cannot write metadata: $!\n";
    my $current_time = strftime("%Y-%m-%d %H:%M:%S", localtime());
    print $fh "Repo name:          $repo_name\n";
    print $fh "Snapshot path:      ~/.gitrewind/${snapshot_base_dir_name}/${repo_name}\n";
    print $fh "Snapshot created:   $current_time\n";
    print $fh "Snapshot timestamp: $timestamp\n";
    print $fh "Branch name:        $BRANCH\n";
    print $fh "Commit hash:        $hash\n";
    print $fh "Commit date:        " . `git show -s --format="%ci" $hash 2>/dev/null`;
    close $fh;
    
    # ==== take snapshot ====
    my $output = `git archive $hash | tar -x -C '$snapshot_dir' 2>&1`;

    if ($? != 0) {
        remove_tree($snapshot_base_dir);
        die "Failed:\n$output\n";
    }

    say $snapshot_dir;
}

# parse flags
GetOptions(
    'cleanup|c'  => \$CLEANUP,
    'list|l'     => \$LIST,
    'branch|b=s' => \$BRANCH,
) or usage();

# cleanup flag
if ($CLEANUP) {
    remove_tree($GITREWIND_DIR) or die "Cannot remove: $!\n" if -d $GITREWIND_DIR;
    exit 0;
}

# list flag
if ($LIST) {
    if (-d $GITREWIND_DIR) {
        my @snapshots = glob("$GITREWIND_DIR/*");
        if (@snapshots) {
            foreach my $snap (sort @snapshots) {
                my $meta_file = "$snap/metadata";
                if (-f $meta_file) {
                    if (open my $fh, '<', $meta_file) {
                        while (my $line = <$fh>) {
                            print "$line";
                        }
                        close $fh;
                        say "";
                    }
                }
            }
        } else {
            say "No snapshots yet";
        }
    } else {
        say "No snapshots yet";
    }
    exit 0;
}

# check env
check_dependencies();
if (system("git rev-parse --git-dir >/dev/null 2>&1")) {
    say "Not git repo\n";
    usage();
}

# branch flag
if (!$BRANCH) {
    $BRANCH = `git branch --show-current 2>/dev/null`;
    chomp $BRANCH;
    if (!$BRANCH) {
        say "You are in 'detached HEAD' state";
        say "Use the -b flag to specify a branch or switch to a branch\n";
        usage();
    }
}

main();
